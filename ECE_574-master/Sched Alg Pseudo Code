//NOTE: much of this sctructure is TBD since the FDS algorithm repeats until all components have been scheduled, we need 
// to determine if looping through our whole vector once can achieve the same thing (I'm still watching the FDS lecture) - Alex

//calculates the probabilites for each element in the passed in vector based on the latency constraint
void calculateFDProb(vectorType componentVector, int latentcy) //TODO make sure we pass in latency for probability calc
{
  for(int j = 0; j < componentVector.size(); j++) //loop until all elements have probabilites
  {
    int width = 0; //TODO remove width alltogether?
    int timeframe[2] = {0,0}; //timeframe = [ASAP, ALAP]
    double probability[latency]; //TODO change to vector type for dynamic sizing?
    
    /*** Compute the time frames ***/
    timeframe[0] = calculateASAPtime(j, vectorType componentVector); 
    timeframe[1] = calculateALAPtime(j, vectorType componentVector);
    width = timeframe[1] - timeframe[0] + 1; //width = ALAP - ASAP + 1

    /*** Compute the operations and type probabilites ***/
    
    //assign probabilities of this element being scheduled for each time interval
    for(int i = 0; i < latency; i++)
    {
      if(i >= timeframe[0] && i <=timeframe[1])
        probability[i] = 1 / width;
      else
        proability[i] = 0;  
    }
    //push back probability array for that vector element
  }
  
}

//computes the type proability distributions, and assign each vector element it's  start and end times
//NOTE this function needs rework
void calculateFDTimes(vectorType componentVector, int latentcy)
{
  /*** Find the type proability distributions ***/
  double ALUDist[latency]; //the distributions for all ALU elements
  double MULDist[latency]; //the distributions for all Multiplier elements
  
  for (int i = 0; i < componentVector.size(); i++)
  {
    if(componentVector[i].type != "MUL") //check if element is an ALU operation
    {
      for(int j = 0; j < latency; j++) //for each time interval, add up the proabilities associated with this vector element
      {
        ALUDist[j] += componentVector[i].probability[j];
      }
    }
  }

  /*** Compute the self-forces, predecessor/successor forces, and total forces ***/

  /*** Schedule the operation with least force and update its time frame ***/
  //push back the FDS start and end time of the component, numScheduledComponents++
}

//Pushes back an index value to an elements predecessor and successor after checking the dependency exists. else pushes back -1
//TODO: add vector predecessor[] to component Vector
assignPredecessors(vectoryType componentVector)
{
  for (vector<int>::size_type i = 0; i != circuitCompVector.size(); i++) //loop for all elements in the vector
  {
    for (vector<int>::size_type j = 0; j != circuitCompVector.size(); j++) //loop for one element (i) checked against all elements (j)
    {
	  int index = 0;
      if(i != j) //don't compare a component to itself
      {
        for(vector<int>::size_type k = 0; k < numberOfOperands; k++) //TODO get numberofOperands, will this loop make the function generic?
        {
			  if(circuitCompVector.at(i).result.getCircuitSignalName() == circuitCompVector.at(j).operands(k) //check if result is found in the operands of the current element
			  {
					circuitCompVector.at(i).predecessor() = j; //TODO change to push back vector in vector
			  }
        }
       } //end k loop
      }
    } //end j loop
  } //end i loop
}

assignSuccessors(vectoryType componentVector)
{
  for (vector<int>::size_type i = 0; i != circuitCompVector.size(); i++) //loop for all elements in the vector
  {
    for (vector<int>::size_type j = 0; j != circuitCompVector.size(); j++) //loop for one element (i) checked against all elements (j)
    {
      if(i != j) //don't compare a component to itself
	  {
		  if(componentVector.at(i).predecessor.size() != 0) //only look at components with a predecessor
		  {
			  for(int predIndex = 0; predIndex < componentVector.at(i).predecessor.size(); predIndex++)
			  {
		          	//push back the componentVector indexed at the value stored in predecessor(predIndex)
				componentVector.at(componentVector.at(i).predecessor(predIndex)).successor = i;
			  }
		  }
	  }
	}
  }
}

calculateALAPtime(int vectorElement, vectorType componentVector)
{
 //push back the component's ALAP start/end times OR return ALAP start time (TBD based on implementation)

 //Check for compnents with with a successor of null.
 for(int i = 0; i<componentVector.size(); ++i)
 {
	//if null set scheduled time to 1
	if(componentVector.at(i).successor == null)
	{
		componentVector.at(i).timeframe[1] = latency;
		//Check found nodes for successors
		
		//This following calculation is broke need to fix it

		int current = componentVector.size()-2;
		while(componentVector.at(current).predecessor != null)
		{
			
			componentVector.at(current).timeframe[1] = current+1;

			current--;
			if(current < 0)
			{
				cout << "Error: ALAP Algorithm requires more than latency allows."
				return;
			}
		}
	}
 }
 
 //Check found nodes for successors.  
 //If succesosrs not null, increcment scheduled time for assignement
 //Repeat from check found until all nodes have successors that are nul
}

calculateASAPtime(int vectorElement, vectorType componentVector)
{
 //push back the component's ASAP start/end times OR return ASAP start time (TBD based on implementation)

 //Check for compnents with with a predecessor of null.
 for(int i = 0; i<componentVector.size(); ++i)
 {
	//if null set scheduled time to 1
	if(componentVector.at(i).predecessor == null)
	{
		componentVector.at(i).timeframe[0] = 1;
		//Check found nodes for successors
		int current = 1;
		while(componentVector.at(current).successor != null)
		{
			
			componentVector.at(current).timeframe[0] = current+1;

			current++;
			if(current > latency)
			{
				cout << "Error: ASAP Algorithm requires more than latency allows."
				return;
			}
		}
	}
 }
 
 //Check found nodes for successors.  
 //If succesosrs not null, increcment scheduled time for assignement
 //Repeat from check found until all nodes have successors that are nul
}

void assignASAPTimes ()
{
	for() //whole component vector
	//for loop and if that check for 0 predecessors
	if(compVect.at(index).predecessor.size() == 0)
		{
			compVect.at(index).time[0] = 1; //empty //ASAP time[0] = 1
			for(int succ = 0; succ < compVect.at(index).successor.size(); succ++)
			{
				tempAsapTime = compVect.at(index).time[0] + compVect.at(index).cycleTime + 1;
				
				if(compVect.at(succ).time[0] <  tempAsapTime)//no other predecessor has a longer (time[0] + cycleTime)
				{
					compVect.at(index).successor(succ).time[0] = tempAsapTime;
					mark compVect.at(i).visited = true
					totalVisited++
				}
			}
		}
		//TODO add global totalVisited
		while(totalVisited != compVector.size())
		{
			int index = 0;
			bool skipElement = false;
			for(; index < compVector.size(); index++)//whole vector size
			{
				if(compVector.at(index).visited != true)
				{
					for(int pred = 0; pred < compVector.at(index).predecessor.size(); pred++) //check all predecessors
					{
						if(compVector.at(compVector.at(index).predecessor(pred)).visited != true) //has any single predecessor not been visited?
						{
							skipElement = true;
							break; //index will be incremented since we break out of the nearest for loop
						}
					}
					if(!skipElement) //if all the predecessors WERE visted, now find which predecessor has the longest time[0]+cycleTime
					{
						//TODO make sure we aren't indexing into a predecessor that doesn't exist for the current compVector.at(index)
						tempAsapTime = compVector.at(compVector.at(index).predecessor(0)).time[0];
						//find the longest ASAP start time (time[0]) of all the predecessors
						for(int predTCheck = 1; predTCheck < compVector.at(index).predecessor.size(); predTCheck++) //check all predecessors
						{
							if(tempAsapTime <  compVector.at(compVector.at(index).predecessor(predTcheck)).time[0])
							{
								tempAsapTime = compVector.at(compVector.at(index).predecessor(predTcheck)).time[0];
							}
							
						}
						compVector.at(index).time[0] = tempAsapTime; //assign the longest start time
						mark compVect.at(i).visited = true; //this node was checked for all it's predecessors, it's done
						totalVisited++; //update total 
					}
					
				}
			}
		}
		
		
}
